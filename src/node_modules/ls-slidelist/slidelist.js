/*
*  SlideList class for storing and manipulating a list of
*  LibreSignage Slides.
*/

var Assert = require('libresignage/util/assert/Assert');

class SlideList {
	constructor() {
		this.slides = {};
	}

	filter(filter) {
		/*
		*  Filter this SlideList. 'filter' is a dictionary of
		*  values that's compared against the data array of all
		*  slides. Slides that match all values in 'filter' are
		*  returned in a new SlideList object.
		*/
		let ret = new SlideList();
		let add = false;
		for (var s in this.slides) {
			add = true;
			for (var k in filter) {
				if (this.slides[s].data[k] != filter[k]) {
					add = false;
					break;
				}
			}
			if (add) { ret.slides[s] = this.slides[s]; }
		}
		return ret;
	}

	next(index, wrap, dir = 1) {
		/*
		*  Get the next slide in this SlideList. 'index' is the
		*  index of the slide preceding the returned slide (ie.
		*  the index of the current slide). If wrap == true, this
		*  function returns the first slide when no more slides exist.
		*  If you set dir = -1, the previous slide is returned instead
		*  of the next one and all other logic is inverted aswell.
		*
		*  How this function works when dir === 1:
		*
		*  - First, this function finds the smallest difference between
		*    the slide indices in 'this.slides' and 'index'.
		*  - If such a difference is not found (ie. d === 0), the current
		*    slide is the last one in the SlideList. If wrap == true,
		*    the first slide is returned. Otherwise null is returned.
		*  - If the difference is found (ie. d !== 0), the new slide index
		*    is calculated (n_i = index + d) and the corresponding slide
		*    is returned.
		*
		*  When dir === -1, the basic principle is the same but the logic
		*  is inverted.
		*/
		var n_d = -1, d = 0, n_i = 0;

		Assert.assert(
			dir === 1 || dir === -1,
			"'dir' argument must be 1 or -1."
		);

		if (!this.length()) { return null; }
		for (let slide of Object.values(this.slides)) {
			n_d = slide.get('index') - index;
			if (dir === 1) {
				if (n_d > 0 && (n_d < d || d === 0)) {
					d = n_d;
				}
			} else if (dir === -1) {
				if (n_d < 0 && (n_d > d || d === 0)) {
					d = n_d;
				}
			}
		}

		if (d === 0 && wrap) {
			// Wrap around.
			if (dir === 1) {
				// Return the slide with the smallest index.
				let r = null;
				for (let slide of Object.values(this.slides)) {
					if (r == null || r.get('index') > slide.get('index')) {
						r = slide;
					}
				}
				return r;
			} else if (dir === -1) {
				// Return the slide with the largest index.
				let r = null;
				for (let slide of Object.values(this.slides)) {
					if (r == null || r.get('index') < slide.get('index')) {
						r = slide;
					}
				}
				return r;
			}
		} else if (d !== 0) {
			n_i = index + d;
			for (let slide of Object.values(this.slides)) {
				if (slide.get('index') == n_i) {
					return slide;
				}
			}
		}
		return null;
	}

	get_slides() { return this.slides; }
	length()     { return Object.keys(this.slides).length; }
}
exports.SlideList = SlideList;
